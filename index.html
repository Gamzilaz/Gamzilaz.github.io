<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D-шары с орбитами и танцем</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Сцена, камеры и рендерер
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const orbitCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); // Камера для вращения вокруг звезды
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Камера на старте
        camera.position.set(10, 10, 10);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        // Камера для вращения
        orbitCamera.position.set(10, 10, 10);
        orbitCamera.lookAt(new THREE.Vector3(0, 0, 0));

        // Управление камерой с помощью мыши
        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Освещение
        const ambientLight = new THREE.AmbientLight(0x202020, 1); // Мягкое фоновое освещение
        scene.add(ambientLight);

        // Создаем точечный источник света (для звезды)
        const starLight = new THREE.PointLight(0xfffec1, 7, 50);  // Желтая точечная лампа
        starLight.position.set(0, 0, 0);  // Звезда в центре
        scene.add(starLight);

        // Геометрия большого и малого шаров
        const largeSphereGeometry = new THREE.SphereGeometry(2, 64, 64);
        const smallSphereGeometry = new THREE.SphereGeometry(0.3, 32, 32); // Маленькие шары

        // Материал для большого шара (с эффектом свечения)
        const largeSphereMaterial = new THREE.MeshStandardMaterial({
            color: 0xffff00, // Цвет материала (жёлтый)
            metalness: 0.0,
            roughness: 0.5,
            emissive: 0xffff00,  // Эмиссия (яркое свечение)
            emissiveIntensity: 1.5
        });

        // Материал для маленьких спутников (с загрузкой текстуры)
        const textureLoader = new THREE.TextureLoader();
        const texture = textureLoader.load('https://i.postimg.cc/3JK2y59M/Earth-Diffuse-6-K-2.jpg'); // Замените на путь к вашей текстуре
        const materialWithTexture = new THREE.MeshStandardMaterial({
            map: texture,
            metalness: 1,    // Металличность
            roughness: 2,    // Шероховатость
            emissive: 0x111921,
        });

        // Меш большого шара (светящейся звезды)
        const largeSphere = new THREE.Mesh(largeSphereGeometry, largeSphereMaterial);
        scene.add(largeSphere);

        // Меш для маленьких спутников с текстурой
        const smallSphere = new THREE.Mesh(smallSphereGeometry, materialWithTexture);
        scene.add(smallSphere);

        const secondSmallSphere = new THREE.Mesh(smallSphereGeometry, materialWithTexture);
        scene.add(secondSmallSphere);

        const thirdSmallSphere = new THREE.Mesh(smallSphereGeometry, materialWithTexture);
        scene.add(thirdSmallSphere);

        // Создаем звездное небо (точки)
        const starCount = 2000;
        const starGeometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];

        for (let i = 0; i < starCount; i++) {
            const x = Math.random() * 2000 - 1000;
            const y = Math.random() * 2000 - 1000;
            const z = Math.random() * 2000 - 1000;
            positions.push(x, y, z);
            colors.push(Math.random(), Math.random(), Math.random());
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const starMaterial = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true
        });

        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Устанавливаем радиусы орбит для спутников
        const orbitRadius = 5;
        const secondOrbitRadius = 7;
        const thirdOrbitRadius = 9;
        const ellipticOrbitRadiusX = 6;  // Эллиптическая орбита по оси X
        const ellipticOrbitRadiusY = 12;  // Эллиптическая орбита по оси Y

        // Разные скорости вращения спутников
        const secondOrbitSpeed = 2 * Math.PI / 29; // Второй спутник: один оборот за 15 секунд
        const thirdOrbitSpeed = 2 * Math.PI / 24; // Третий спутник: один оборот за 20 секунд
        const ellipticOrbitSpeed = 2 * Math.PI / 20; // Спутник на эллиптической орбите: один оборот за 25 секунд
        const orbitSpeed = 2 * Math.PI / 15;  // Малый спутник вращается за 10 секунд

        // Функция для создания орбит (кольца)
        function createOrbit(radiusX, radiusY, segments) {
            const orbitGeometry = new THREE.RingGeometry(radiusX - 0.025, radiusX + 0.025, segments);
            const orbitMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                opacity: 0.1,  // Прозрачность 10%
                transparent: true, // Включение прозрачности
                depthWrite: false // Отключение глубины для правильного отображения колец
            });
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = Math.PI / 2; // Поворачиваем орбиту, чтобы она была горизонтальной
            scene.add(orbit);
            return orbit;
        }

        // Функция для создания эллиптической орбиты
        function createEllipticOrbit(radiusX, radiusY, segments) {
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = Math.cos(angle) * radiusX;
                const y = Math.sin(angle) * radiusY;
                points.push(x, 0, y);
            }

            const ellipticOrbitGeometry = new THREE.BufferGeometry();
            ellipticOrbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            const ellipticOrbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.1, transparent: true });
            const ellipticOrbitLine = new THREE.LineLoop(ellipticOrbitGeometry, ellipticOrbitMaterial);
            scene.add(ellipticOrbitLine);
            return ellipticOrbitLine;
        }

        // Создаем орбиты для спутников
        const firstOrbit = createOrbit(orbitRadius, orbitRadius, 128);
        const secondOrbit = createOrbit(secondOrbitRadius, secondOrbitRadius, 128);
        const thirdOrbit = createOrbit(thirdOrbitRadius, thirdOrbitRadius, 128);
        const ellipticOrbit = createEllipticOrbit(ellipticOrbitRadiusX, ellipticOrbitRadiusY, 128);

        // Создаем новый спутник для эллиптической орбиты
        const ellipticSmallSphere = new THREE.Mesh(smallSphereGeometry, materialWithTexture);
        scene.add(ellipticSmallSphere);

        // Функция орбитального движения
        function orbitAround() {
            const time = Date.now() * 0.001;

            smallSphere.position.x = Math.cos(time * orbitSpeed) * orbitRadius;
            smallSphere.position.z = Math.sin(time * orbitSpeed) * orbitRadius;

            secondSmallSphere.position.x = Math.cos(time * secondOrbitSpeed) * secondOrbitRadius;
            secondSmallSphere.position.z = Math.sin(time * secondOrbitSpeed) * secondOrbitRadius;

            thirdSmallSphere.position.x = Math.cos(time * thirdOrbitSpeed) * thirdOrbitRadius;
            thirdSmallSphere.position.z = Math.sin(time * thirdOrbitSpeed) * thirdOrbitRadius;

            ellipticSmallSphere.position.x = Math.cos(time * ellipticOrbitSpeed) * ellipticOrbitRadiusX;
            ellipticSmallSphere.position.z = Math.sin(time * ellipticOrbitSpeed) * ellipticOrbitRadiusY;

            // Вращение большого шара
            largeSphere.rotation.x += 0.005;
            largeSphere.rotation.y += 0.005;
        }

        // Пульсация свечения звезды
        let pulsateIntensity = 1.5;
        let pulsateSpeed = 0.003;

        function animate() {
            requestAnimationFrame(animate);

            // Пульсация свечения большого шара
            pulsateIntensity = 1.5 + Math.sin(Date.now() * pulsateSpeed) * 0.5;
            largeSphereMaterial.emissiveIntensity = pulsateIntensity;

            // Вращение вокруг большой звезды
            orbitAround();

            // Очень медленное вращение камеры
            camera.position.x = 10 * Math.cos(Date.now() * 0.00005);
            camera.position.z = 10 * Math.sin(Date.now() * 0.00005);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            // Рендеринг сцены
            renderer.render(scene, camera);
        }

        animate();

        // Обработчик изменения размера окна
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        // Обработчик нажатия клавиш для смены ракурсов
        let activeCamera = camera; // Изначально используем основную камеру

        window.addEventListener('keydown', (event) => {
            switch(event.key) {
                case '1':
                    activeCamera = camera;
                    camera.position.set(10, 20, 10); // Камера сверху
                    camera.lookAt(new THREE.Vector3(0, 0, 0));
                    break;
                case '2':
                    activeCamera = camera;
                    camera.position.set(0, 10, 10); // Камера на уровне объектов
                    camera.lookAt(new THREE.Vector3(0, 0, 0));
                    break;
                case '3':
                    activeCamera = camera;
                    camera.position.set(10, 0, 10); // Камера сбоку
                    camera.lookAt(new THREE.Vector3(0, 0, 0));
                    break;
                case '4':
                    activeCamera = camera;
                    camera.position.set(15, 15, 15); // Камера в 3D перспективе
                    camera.lookAt(new THREE.Vector3(0, 0, 0));
                    break;
                case '5':
                    activeCamera = orbitCamera;
                    orbitCamera.position.set(10, 10, 10);
                    break;
            }
        });

        // Вращение камеры при переключении
        function updateCamera() {
            controls.update();  // Обновление управления для OrbitControls
        }

        // Обновляем и рендерим
        function animateWithUpdate() {
            requestAnimationFrame(animateWithUpdate);
            updateCamera();
            renderer.render(scene, activeCamera);
        }

        animateWithUpdate();
    </script>
</body>
</html>
